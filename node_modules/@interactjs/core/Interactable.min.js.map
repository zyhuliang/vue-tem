{
	"version": 3,
	"sources": [
		"Interactable.ts"
	],
	"names": [
		"Eventable",
		"isNonNativeEvent",
		"arr",
		"browser",
		"clone",
		"getElementRect",
		"matchesUpTo",
		"nodeContains",
		"trySelector",
		"extend",
		"is",
		"normalizeListeners",
		"getWindow",
		"Interactable",
		"_defaults",
		"base",
		"perAction",
		"actions",
		"constructor",
		"target",
		"options",
		"defaultContext",
		"scopeEvents",
		"this",
		"_actions",
		"events",
		"_context",
		"_win",
		"_doc",
		"_scopeEvents",
		"context",
		"document",
		"set",
		"setOnEvents",
		"actionName",
		"phases",
		"func",
		"onstart",
		"on",
		"onmove",
		"onend",
		"oninertiastart",
		"updatePerActionListeners",
		"prev",
		"cur",
		"array",
		"object",
		"off",
		"setPerAction",
		"defaults",
		"optionName_",
		"optionName",
		"actionOptions",
		"optionValue",
		"listeners",
		"from",
		"plainObject",
		"enabled",
		"bool",
		"getRect",
		"element",
		"string",
		"querySelector",
		"rectChecker",
		"checker",
		"_backCompatOption",
		"newValue",
		"action",
		"map",
		"origin",
		"deltaSource",
		"inContext",
		"ownerDocument",
		"testIgnoreAllow",
		"targetNode",
		"eventTarget",
		"testIgnore",
		"ignoreFrom",
		"testAllow",
		"allowFrom",
		"fire",
		"iEvent",
		"_onOff",
		"method",
		"typeArg",
		"listenerArg",
		"addRemove",
		"type",
		"wheelEvent",
		"listener",
		"types",
		"actionName_",
		"methodDict",
		"methodName",
		"setting",
		"unset",
		"delegatedEvents",
		"delegated",
		"i",
		"length",
		"selector",
		"splice",
		"l",
		"removeDelegate",
		"remove"
	],
	"mappings": "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",
	"sourcesContent": [
		"import Eventable from './Eventable'\nimport { ActionDefaults, Defaults, Options } from './defaultOptions'\nimport { Actions, isNonNativeEvent } from './scope'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport * as is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\ntype IgnoreValue = string | Interact.Element | boolean\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  protected get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Interact.Target\n  readonly events = new Eventable()\n  readonly _context: Interact.Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Interact.Scope['events']\n\n  /** */\n  constructor (target: Interact.Target, options: any, defaultContext: Document | Interact.Element, scopeEvents: Interact.Scope['events']) {\n    this._actions = options.actions\n    this.target   = target\n    this._context = options.context || defaultContext\n    this._win     = getWindow(trySelector(target) ? this._context : target)\n    this._doc     = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: Interact.ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) { this.on(`${actionName}start`, phases.onstart) }\n    if (is.func(phases.onmove)) { this.on(`${actionName}move`, phases.onmove) }\n    if (is.func(phases.onend)) { this.on(`${actionName}end`, phases.onend) }\n    if (is.func(phases.oninertiastart)) { this.on(`${actionName}inertiastart`, phases.oninertiastart) }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: Interact.ActionName, prev: Interact.Listeners, cur: Interact.Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: Interact.ActionName, options: Interact.OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof Interact.PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Interact.Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array<any>(optionValue)) {\n        (actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        (actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || {} as any,\n          clone(optionValue))\n\n        // set anabled field to true if it exists in the defaults\n        if (is.object(defaults.perAction[optionName]) && 'enabled' in (defaults.perAction[optionName] as any)) {\n          (actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        (actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        (actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {object} The object's bounding rectangle.\n   */\n  getRect (element: Interact.Element) {\n    element = element || (is.element(this.target)\n      ? this.target\n      : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (checker: (element: Interact.Element) => any) {\n    if (is.func(checker)) {\n      this.getRect = checker\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Interact.Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      (this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        (this.options[action][optionName] as any) = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (newValue?: string) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return (this._context === element.ownerDocument ||\n            nodeContains(this._context, element))\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Interact.EventTarget,\n  ) {\n    return (!this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n            this.testAllow(options.allowFrom, targetNode, eventTarget))\n  }\n\n  testAllow (\n    this: Interactable,\n    allowFrom: IgnoreValue,\n    targetNode: Node,\n    element: Interact.EventTarget,\n  ) {\n    if (!allowFrom) { return true }\n\n    if (!is.element(element)) { return false }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    }\n    else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (\n    this: Interactable,\n    ignoreFrom: IgnoreValue,\n    targetNode: Node,\n    element: Interact.EventTarget,\n  ) {\n    if (!ignoreFrom || !is.element(element)) { return false }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    }\n    else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent: object) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: Interact.EventTypes, listenerArg?: Interact.ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') { type = browser.wheelEvent }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](this.target, this._context, type, listener, options)\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: Interact.OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    (this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as Interact.ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n\n      this[methodName](options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func(this[setting])) {\n        this[setting](options[setting])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1])\n          }\n        }\n      }\n    }\n    else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n\nexport default Interactable\n"
	]
}